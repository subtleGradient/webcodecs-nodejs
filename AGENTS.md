# AGENTS.md

## Project Goal

**NEW STRATEGY**: Fork and perfect `node-webcodecs` (caseymanos/node-webcodecs).

We discovered an existing MIT-licensed implementation that passes 87/88 of our tests.
Instead of building from scratch, we're contributing to make it 100% spec-compliant.

### Why Fork Instead of Build?
- `node-webcodecs` already has working VP8, VP9, H.264, HEVC, AV1, Opus, AAC
- Hardware acceleration support (VideoToolbox, NVENC, QSV, VAAPI)
- Worker thread pool for async encoding
- 87/88 tests passing - only 1 audio timestamp bug found

### Our Contribution Strategy
1. Add implementation-agnostic vitest test suite (runs in browser AND Node.js)
2. Find and fix spec compliance gaps
3. Submit PRs to upstream
4. Help them win (or share) the $10k challenge

### Repository Structure
- `node-webcodecs-fork/` - Git submodule of our fork (subtleGradient/node-webcodecs)
- Tests run against fork with `npm run test:spec` in the submodule

## Development Methodology: Kent Beck-Style RGR TDD

We follow strict Red-Green-Refactor Test-Driven Development:

1. **RED**: Write a failing test first. The test defines the requirement.
   - **CRITICAL**: Run the test in the BROWSER first (`npm run test:browser`) to verify it passes with the native WebCodecs API. If the test fails in the browser, the test itself is wrong—fix the test before proceeding to GREEN.
2. **GREEN**: Write the minimum code to make the test pass. No more.
3. **REFACTOR**: Clean up without changing behavior. Tests must stay green.
4. **COMMIT & PUSH**: After each RGR cycle when tests pass, commit and push.

### Git Workflow

**CRITICAL: Two-repo workflow (parent + submodule)**

We have TWO git repositories to maintain:
1. **Parent repo** (`2025-12-03-subtleGradient-webcodecs-nodejs/`) - Our test harness, AGENTS.md, research
2. **Submodule** (`node-webcodecs-fork/`) - The fork we're improving

**After changes to the SUBMODULE (node-webcodecs-fork/):**
```bash
cd node-webcodecs-fork
git add -A && git commit -m "fix: description" && git push origin add-vitest-spec-tests
cd ..
git add node-webcodecs-fork  # Update submodule reference in parent
```

**After changes to the PARENT repo:**
```bash
git add -A && git commit -m "docs: update AGENTS.md" && git push
```

**After each RGR cycle:**
1. Run tests to verify changes work
2. Commit to appropriate repo (submodule first if both changed)
3. Push immediately - don't batch commits
4. **Update AGENTS.md** status checkboxes to reflect progress

Commit message format:
- `feat:` - New feature or capability
- `fix:` - Bug fix
- `refactor:` - Code cleanup without behavior change
- `test:` - Test-only changes
- `docs:` - Documentation changes
- `chore:` - Build/tooling changes

### Keeping AGENTS.md Fresh

**MANDATORY**: Update this file whenever:
- A task is completed (check the box)
- A new issue is discovered (add to Known Issues)
- Strategy changes (update Project Goal section)
- New learnings (add to relevant section)

**Never let AGENTS.md go stale** - it's the source of truth for project status.

### Scientific Verification Principle

We use "secret color" tests to prove real work is happening:
- Encode a frame with a specific RGB color (e.g., `#DEADBE`)
- Decode it back and verify the color matches (within compression tolerance)
- If the color is wrong, the codec is broken. No false positives.
- Use QR codes for verification (survive lossy compression with error correction). See `research/lossless-verification.md`.

### Peer-Reviewable Evidence

All claims must be reproducible by reviewers:

1. **Fixture Generation Scripts**: All test fixtures are generated by scripts in `fixtures/generate.ts`. Reviewers can regenerate them with `npm run generate:fixtures`.

2. **Manifest Files**: Each fixture directory contains a `manifest.json` with:
   - Exact FFmpeg command used to generate
   - Input parameters (color, dimensions, codec settings)
   - Expected output checksums
   - Timestamp of generation

3. **Raw + Encoded Pairs**: Fixtures include both:
   - `.rgb24` - Raw pixel data (ground truth)
   - `.ivf` / `.mp4` - Encoded data
   - Reviewers can verify by decoding with standard tools (FFmpeg CLI)

4. **Verification Commands**: Each test includes comments showing equivalent FFmpeg commands reviewers can run independently.

5. **No Binary Blobs Without Source**: Never commit generated binaries without the script that created them. If a fixture exists, its generation script must also exist.

### OODA + RGR Planning Loop

We combine the OODA loop (Observe-Orient-Decide-Act) with RGR to stay nimble and avoid local optima:

1. **OBSERVE**: After each RGR cycle, assess progress against the larger goal
2. **ORIENT**: Ask "Are we still on the critical path? Is there a better approach now that we know more?"
3. **DECIDE**: Choose the next highest-impact task (not just the next logical step)
4. **ACT**: Execute one RGR cycle, then loop back to OBSERVE

**Avoiding Local Optima** (with concrete thresholds):
- **Time limit per RGR cycle**: If a single RED→GREEN cycle takes more than **3 failed attempts** or **30 minutes of wall-clock time**, STOP. Either:
  1. Simplify the test to something smaller
  2. Skip and stub it, move on to the next task
  3. Ask for help / research more before continuing
- **Zoom-out trigger**: After every **3 commits**, explicitly ask: "What's the shortest path to a working end-to-end demo?"
- **Gold-plating detection**: If you're refactoring something that already passes tests, limit to **1 refactor pass**. Ship it.
- **End-to-end over depth**: A working encode→decode round-trip with 1 codec beats a perfect decoder for 4 codecs with no encoder.

### Task Priority Order

1. **Critical Path**: Test fixtures → Build infra → VideoDecoder → VideoEncoder
2. **Validation**: Round-trip tests with secret color verification
3. **Expansion**: Add codecs (H.264, VP9, audio)

## Commands

### Build & Test
- `npm test` - run all tests
- `npm run test:watch` - run tests in watch mode
- `npx vitest run tests/webcodecs.test.ts` - run a single test file
- `npx vitest run -t "VideoEncoder"` - run tests matching pattern
- `npm run build` - build TypeScript to dist/
- `npm run typecheck` - type-check without emitting

### Native Addon
- `npm run build:native` - compile N-API addon with node-gyp
- `npm run rebuild` - clean rebuild of native addon

### Test Fixtures
- `npm run generate:fixtures` - generate encoded test data with secret colors

## Code Style

### TypeScript
- Strict mode enabled, ES2022 target, ESM modules
- Use ES module imports (`import x from 'y'`), no CommonJS
- Prefer explicit types for public APIs; use `interface` for object shapes
- PascalCase for classes/interfaces, camelCase for functions/variables, UPPER_CASE for constants
- Use `_` prefix for private class members (e.g., `_state`)
- Throw `DOMException` with appropriate error names (e.g., `InvalidStateError`)

### C++ (Native Addon)
- Use `node-addon-api` (C++ wrapper for N-API)
- Class names: `Native{ClassName}` (e.g., `NativeVideoDecoder`)
- One class per file in `src/native/`
- Use RAII for resource management
- All FFmpeg calls wrapped with error checking
- Thread-safe function (TSFN) for callbacks to JS

### Tests
- Use vitest with `describe`/`it`/`expect`
- Import from `vitest`
- Cleanup in `afterEach`
- Each test should be independent
- Use descriptive test names that explain the requirement
- **Implementation-agnostic**: Tests must work with ANY spec-compliant WebCodecs implementation (browser, Node.js, Deno, Bun). Do not test implementation details—test the WebCodecs API contract.
- Use QR codes for verification (survive lossy compression with error correction). See `research/lossless-verification.md`.

## Project Structure

```
src/
  index.ts              # Main exports, JS API layer
  codec-parser.ts       # Codec string parser (avc1.* → FFmpeg params)
  native/
    binding.gyp         # Build configuration
    addon.cc            # N-API module entry point
    video_decoder.cc    # NativeVideoDecoder implementation
    video_decoder.h
    video_encoder.cc    # NativeVideoEncoder implementation
    video_encoder.h
    video_frame.cc      # NativeVideoFrame (wraps AVFrame*)
    video_frame.h
    command_queue.cc    # Thread-safe command queue
    command_queue.h
    worker_thread.cc    # Per-instance worker thread
    worker_thread.h

tests/
  setup.ts              # Test setup with polyfill loading
  webcodecs.test.ts     # API conformance tests
  codec-parser.test.ts  # Codec string parser tests
  native-decode.test.ts # Native decoder integration tests
  native-encode.test.ts # Native encoder integration tests
  round-trip.test.ts    # Encode→Decode verification with secret colors

fixtures/
  generate.ts           # Script to generate test fixtures
  vp8/
    keyframe-red.bin    # VP8 keyframe with known color
    keyframe-secret.bin # VP8 keyframe with secret color for verification
  h264/
    ...

research/              # Research documentation
tasks/                 # Implementation task tracking

.refs/                 # Git submodules with reference implementations
  bun/                 # Bun runtime source (N-API examples, JavaScriptCore)
  effect/              # Effect-TS ecosystem
  effect-native/       # Effect native bindings patterns
  effect-smol/         # Lightweight Effect patterns
  FFmpeg/              # FFmpeg source code reference
  libavjs-webcodecs-polyfill/  # WebCodecs polyfill using libav.js
  mediabunny/          # Media processing library
  remotion/            # Remotion video framework (WebCodecs usage examples)
```

## FFmpeg Integration

### Required Libraries
- `libavcodec` - codec implementations
- `libavformat` - container formats (for test fixture generation)
- `libavutil` - utilities, pixel formats
- `libswscale` - pixel format conversion (for copyTo)

### Codec Priority
1. VP8 (libvpx) - simplest, royalty-free, good for initial development
2. H.264 (libx264/libopenh264) - most common
3. VP9 (libvpx-vp9) - modern royalty-free
4. AV1 (libaom/libdav1d) - future-proof

### Linking Strategy
- Static linking for distribution (self-contained binary)
- Dynamic linking for development (faster iteration)

## Current Sprint Tasks

See the todo list in the conversation for current task status.

### Phase 1: Validate & Test (COMPLETE)
- [x] Discover node-webcodecs exists and works (87/88 tests pass)
- [x] Fork to subtleGradient/node-webcodecs
- [x] Add as git submodule
- [x] Add vitest spec-compliance test suite (159 tests now!)
- [x] Run browser tests to validate tests against native WebCodecs (all pass)

### Phase 2: End-to-End Verification (COMPLETE)
- [x] Add QR code round-trip verification tests (video)
- [x] Test VP8, VP9, H.264, HEVC, AV1 codecs with QR verification
- [x] Add audio round-trip verification tests (Opus, AAC, FLAC)
- [x] Test multiple resolutions (128x128 to 640x480)
- [x] Test multiple bitrates (500kbps to 5Mbps)
- [x] Document encode-after-flush bug (HIGH severity, fails in node-webcodecs)

### Phase 3: Known Bugs (documented in .beads/spec-compliance-bugs.md)
- [x] Fix audio timestamp bug (time_base + initial_padding compensation)
- [ ] Fix VideoFrame/AudioData properties not resetting after close
- [ ] Fix encode-after-flush producing no output on second batch
- [ ] Add missing `ondequeue` event handler

### Phase 4: Polish & Ship
- [ ] Submit PRs to upstream with all test improvements
- [ ] Documentation improvements
- [ ] Help upstream with CI/CD, prebuilds
